<h3 class="centered">Drab - Server Side DOM Access - proof of concept</h3>
<p>
  In the <i>"good old times"</i> the event handling was easy. The only you have to do is to create the event handler (remember <code>TForm1.Button1Click(Sender: TObject)</code>?) and you could do everything inside this handler: accessing data from models, manipulating user interface, sending raw Ethernet packets to the coffee machine...
</p>
<p>
  Now, while most of the applications are web based, it is not so easy anymore. You need either to create a form and submit the data via POST or GET or use AJAX to send or retrieve data. All inteface manipulation is on the client side. In practice, you need to write two applications: on the client and the server side.  
</p>
<p>
  Additionally, because <code>http</code> is stateless and one-way protocol, it is not easy to communicate back from the server to the browser - like, for example, while executing long running processing, when there is a need to update status (eg. progress bar) or ask the operator about something (like "would you like to continue?"). Of course there are workarounds for this, like polling the server every few seconds to have a status, or even auto-refresh the page, but they are just workarounds. The solution would be to have an access to the interface directly from the server side. And here comes <code>Drab</code>.
</p>
<p>
  <code>Drab</code> is a concept of <b>having an access to DOM objects on the server side</b>, just like in the good-old Delphi times. Please review the following examples. Warning: <b>this is a proof-of-concept only</b>, a lot of things are still not implemented, some are hardcoded (this is a single controller application so far). Any comments, criticism, thoughts are welcome - <a href="mailto:grych@tg.pl?Subject=Drab">grych@tg.pl</a>. Please give me you feedback how do you like this concept!
</p>
<p>
  Drab is written using Phonenix on Elixir, so all the code below is HTML and Elixir (no Javascript!). <b>This page is a living demo - all examples are actually working in Drab</b>.
  All the magic is available because of the websockets. JS side depends on jQuery. You can find a source code of this page <a href="https://github.com/grych/drab-poc">on Github</a>.
</p>
<p><small>Tomek "Grych" Gryszkiewicz 2016</small></p>
<hr>
<div class="row">
  <div class="col-md-7">
    <p>Here is the simplest example  - text input and the button. Clicking the button input text will be uppercased. Awesome!</p>
    <p>
      On the <b>client side</b> we have only HTML (notice - no javascript required anymore!) with the input and the button. The only thing which might be new is the <code>drab-click</code> attribute with "uppercase" value. What is this value? This is a name of the <b>function on the server side</b>, in <code>DrabPoc.PageController</code> module.
<pre><code class="html"><%=~s(<input id="text_to_uppercase" value="uppercase me">
<button drab-click="uppercase">Do it</button>)%></code></pre>
    </p>
    <p>
      Below is this function. Let's repeat: clicking on the <code>&lt;button&gt;</code> in the browser runs <code>DrabPoc.PageController.uppercase/2</code> on server.
<pre><code class="elixir"><%=~s[defmodule DrabPoc.PageController do
  def uppercase(socket, sender) do
    t = List.first(Drab.Query.val(socket, "#text_to_uppercase"))
    Drab.Query.val(socket, "#text_to_uppercase", String.upcase(t))
    {socket, sender}
  end
end]%></code></pre>
      How does it work? <code>Drab.Query.val(socket, "#text_to_uppercase")</code> launches jQuery <code>$("#text_to_uppercase").val()</code> on the client side and returns it to the server. <code>List.first()</code> is used because jQuery always returns an array. Then, the returned string is converted to uppercase using <code>String.upcase</code> and passed to <code>Drab.Query.val/3</code> function, which - analogically to jQuery <code>.val(value)</code> sets the value of the input. 
    </p>

  </div>

  <div class="col-md-5">
    <p>
      This is a live demo. Click the button to launch <code>DrabPoc.PageController.uppercase/2</code> on the server.
      <br><br>
      <input class="form-control" id="text_to_uppercase" value="uppercase me">
      <button class="btn btn-primary" drab-click="uppercase">Do it</button>
    </p>
  </div>
</div>
<hr>
<div class="row">
  <div class="col-md-7">
    <p>
      Let's move to some more complicated functionality. Assume we have a process which is doing some stuff on the server side and we want to report back to the user after each completed step. We will use the progress bar controlled from the server. <br>
      Client side is again very simple. Please notice the <code>drab-click</code> attribute, again. This time it will run <code>perform_long_process</code> function.
<pre><code class="html"><%=~s[<div class="progress">
  <div class="progress-bar" role="progressbar" style="width:0%">
  </div>
</div>
<button drab-click="perform_long_process">Click me to start processing ...</button>]%></code></pre>
      On the server we simulate a long processing by sleeping some random time. The interesting comes with <code>Drab.Query</code> module again: <code>Drab.Query.attr</code> retrieves (<code>/3</code>) or sets (<code>/4</code>) object attributes. In this case, we used it to set <code>style="width: XX%"</code>. <code>Drab.Query.html/3</code> in the next line, sets the progress bar text. Finally, after the loop progress bar changes its color to indicate success.
<pre><code class="elixir"><%=~S[defmodule DrabPoc.PageController do
  def perform_long_process(socket, sender) do
    for i <- 1..10 do
      :timer.sleep(:rand.uniform(750))
      Drab.Query.attr(socket, ".progress-bar", "style", "width: #{10*i}%")
      Drab.Query.html(socket, ".progress-bar", "#{10*i}%")
    end
    Drab.Query.add_class(socket, ".progress-bar", "progress-bar-success")
    {socket, sender}
  end
end]%></code></pre>
      Easy, huh? And <b>no need to code javascript at all</b>.
    </p>
  </div>

  <div class="col-md-5">
    Click on a button to simulate long-running process on the server.
    <div class="progress">
      <div class="progress-bar" role="progressbar" style="width:0%">
      </div>
    </div>
    <button class="btn btn-primary" drab-click="perform_long_process">Click me to start processing ...</button>
  </div>
</div>
<hr>
<div class="row">
  <div class="col-md-7">
    <p>
      In the next example we will emulate long running server process composed of a number of Tasks, which can be run asynchronously. We want to run it in parallel, change their status when they finish the job and - when all of them are finished - change the status of the whole process.
    </p>
    <p>
      HTML side contains button with <code>drab-click</code> attribute and few DIVs which displays the status of the process and tasks:
<pre><code class="html"><%=~s(Async task status: 
<span id="async_task_status" class="label label-primary">
  ready
</span>
<span class="task label label-danger" data-task_id="1">Task 1</span>
  ...
<span class="task label label-danger" data-task_id="54">Task 54</span>
<button drab-click="run_async_tasks">Start async task</button>)%></code></pre>
    </p>
    <p>
      The whole processing is on the server side. Clicking the button runs <code>run_async_tasks/2</code> function on the controller:
<pre><code class="elixir"><%=~s/def run_async_tasks(socket, dom_sender) do
  Drab.Query.html(socket, "#async_task_status", "running")
  tasks = Enum.map(1..54, fn(i) -> Task.async(fn -> 
    :timer.sleep(:rand.uniform(4000))
    Drab.Query.exchange_class(socket, ".task[data-task_id=#\{i\}]", "label-danger", "label-success")
    end)
  end)
  Enum.map(tasks, fn(task) -> Task.await(task) end)
  Drab.Query.html(socket, "#async_task_status", "finished")
  {socket, dom_sender}
end/%></code></pre>
    The code above runs asynchronously 5 Tasks, which just waits some time (up to 4 seconds) and after they "finish the job", shows that it is finished in the user interface by changing the boostrap class from <code>label-danger</code> to <code>label-success</code>. After launching he background tasks, it <code>Task.await/1</code> for all of the tasks to finish and then inform the user by changing the Task status to "finished".
    </p>
    <p>
      You may think: what is the difference between this approach and running 54 AJAX requests which launches action on the controller side? Except of <code>Drab</code> natural beauty, you can't do it with AJAX. You browser <a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">limits the number of simultaneus connections</a>.
    </p>
  </div>
  <div class="col-md-5">
    <p>
      Click the button below to simulate server-side long running process contains asynchronous tasks.
      <h4>Async task status: <span id="async_task_status" class="label label-primary">ready</span></h4>
      <div class="row">
        <%= for i <- 1..54 do %>
          <div class="col-md-2 col-sm-4 centered">
            <span class="task label label-danger" data-task_id="<%= i %>">Task #<%= i |> Integer.to_string |> String.rjust(2, ?0) %></span>
          </div>
        <% end %>
      </div>
      <br>
      <button class="btn btn-primary" drab-click="run_async_tasks">Start async task</button>
    </p>
  </div>
</div>
<hr>

