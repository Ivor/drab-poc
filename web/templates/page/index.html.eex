<h3 class="centered">Drab - Server Side DOM Access - Proof of Concept</h3>
<p>
  In the <i>"good old times"</i> the event handling was easy. The only you have to do is to create the event handler (remember <code>TForm1.Button1Click(Sender: TObject)</code>?) and you could do everything inside this handler: accessing data from models, manipulating user interface, sending raw Ethernet packets to the coffee machine...
</p>
<p>
  Now, whem the most of the applications are web based, it is not so easy anymore. You need either to create a form and submit the data via POST or GET or use AJAX to send or retrieve data. All inteface manipulation is on the client side. In practice, you need to write two applications: on the client and the server side.  
</p>
<p>
  Additionally, because <code>http</code> is stateless and one-way protocol, it is not easy to communicate back from the server to the browser - like, for example, while executing long running processing, when there is a need to update status (eg. progress bar) or ask the operator about something (like "would you like to continue?"). Of course there are workarounds for this, like polling the server every few seconds to have a status, or even auto-refresh the page, but they are just workarounds. The solution would be to have an access to the interface directly from the server side. And here comes <code>Drab</code>.
</p>
<p>
  <code>Drab</code> is a concept of <b>having an access to DOM objects on the server side</b>, just like in the good-old Delphi times. Please review the following examples. Warning: <b>this is a proof-of-concept only</b>, a lot of things are still not implemented, some are hardcoded. Any comments, criticism, thoughts are welcome - <a href="mailto:grych@tg.pl?Subject=Drab">grych@tg.pl</a>. Please give me you feedback how do you like this concept!
</p>
<p>
  Drab is written using Phonenix on Elixir, so all the code below is HTML and Elixir (no Javascript!). <b>This page is a living demo - all examples are actually working in Drab</b>.
  All the magic is available because of the websockets. JS side depends on jQuery. You can find a source code of this page <a href="https://github.com/grych/drab-poc">on Github</a>, and the <a href="https://github.com/grych/drab">source code of the Drab himself - here</a>.
</p>
<p><small>Tomek "Grych" Gryszkiewicz 2016</small></p>
<hr>
<div class="row">
  <h4>Simple Input and Button Example</h4>
  <div class="col-md-7">
    <p>Here is the simplest example  - text input and the button. Clicking the button make input text uppercase. Awesome!</p>
    <p>
      On the <b>client side</b> we have basic HTML with the input and the button:
<pre><code class="html"><%=~s(<input id="text_to_uppercase" value="uppercase me">
<button drab-click="uppercase">Do it</button>)%></code></pre>
    </p>
    <p>
      The only thing which might be new is the <code>drab-click</code> attribute with "uppercase" value. What is this value? This is a name of the <b>function on the server side</b>, in <code>DrabPoc.PageCommander</code> module (see code below). Clicking on the <code>&lt;button&gt;</code> <b>in the browser</b> runs <code>DrabPoc.PageCommander.uppercase/2</code> <b>on the server!</b>
<pre><code class="elixir"><%=~s[defmodule DrabPoc.PageCommander do
  use Drab.Commander
  def uppercase(socket, sender) do
    t = List.first(Drab.Query.select(socket, "#text_to_uppercase", :val))
    Drab.Query.update(socket, "#text_to_uppercase", :val, String.upcase(t))
    {socket, sender}
  end
end]%></code></pre>
      How does it work? <code>Drab.Query.select(socket, "#text_to_uppercase", :val)</code> launches jQuery <code>$("#text_to_uppercase").val()</code> on the client side and returns it to the server. <code>List.first()</code> is used because jQuery always returns an array. Then, the returned string is converted to uppercase using <code>String.upcase</code> and passed to <code>Drab.Query.update/4</code> function, which - analogically to jQuery <code>.val(value)</code> sets the value of the input. 
    </p>

  </div>

  <div class="col-md-5">
    <p>
      This is a live demo. Click the button to launch <code>Drab.Controller.uppercase/2</code> on the server.
      <br><br>
      <input class="form-control" id="text_to_uppercase" value="uppercase me">
      <button class="btn btn-primary" drab-click="uppercase">Do it</button>
    </p>
  </div>
</div>
<hr>
<div class="row">
  <h4>Long Running Process with Communication Back to Browser</h4>
  <div class="col-md-7">
    <p>
      Let's move to some more complicated functionality. Assume we have a process which is doing some stuff on the server side and we want to report back to the user after each completed step. We will use the progress bar controlled from the server. <br>
      Client side is again very simple. Please notice the <code>drab-click</code> attribute, again. This time it will run <code>perform_long_process</code> function.
<pre><code class="html"><%=~s[<div class="progress">
  <div class="progress-bar" role="progressbar" style="width:0%">
  </div>
</div>
<button drab-click="perform_long_process">Click me to start processing ...</button>]%></code></pre>
      On the server we simulate a long processing by sleeping some random time. The interesting comes with <code>Drab.Query</code> module again: <code>Drab.Query.attr</code> retrieves (<code>/3</code>) or sets (<code>/4</code>) object attributes. In this case, we used it to set <code>style="width: XX%"</code>. Nn the next line <code>Drab.Query.html/3</code> changes the text of the progress bar. Finally, after the loop finishes, progress bar changes its color to indicate success.
<pre><code class="elixir"><%=~S[def perform_long_process(socket, dom_sender) do
  steps = :rand.uniform(100)
  for i <- 1..steps do
    :timer.sleep(:rand.uniform(500)) # simulate real work
    socket 
      |> update(".progress-bar", :attr, "style", "width: #{i * 100 / steps}%")
      |> update(".progress-bar", :html, "#{Float.round(i * 100 / steps, 2)}%")
  end
  insert(socket, ".progress-bar", :class, "progress-bar-success")
  {socket, dom_sender}
end]%></code></pre>
      All <em>setter</em> functions (functions which manipulates DOM objects, like <code>Drab.Query.attr/4</code>) return <code>socket</code> which allows us to use the pipe syntax. Additionally, there is no need to use the whole <code>Drab.Query</code> module path, <code>use Drab.Commander</code> provides the required imports.
      Easy, huh? And <b>no need to code javascript at all</b>.
    </p>
    <p>
      By the way, when you click the button again while it is processing, you'll observe the strange phenomenas. This is because all processing in Drab is asynchronous, so clicking the button again launches another process on the server side and both the processes changes the properties of the same DOM object. What a mess! This is why the buttons should be disable when corresponding action is processing on the server. It will be exaplained in a few moments.
    </p>
  </div>

  <div class="col-md-5">
    Click on a button to simulate long-running process on the server.
    <div class="progress">
      <div class="progress-bar" role="progressbar" style="width:0%">
      </div>
    </div>
    <button class="btn btn-primary" drab-click="perform_long_process">Click me to start processing ...</button>
  </div>
</div>
<hr>
<div class="row">
  <h4>Tens of Tasks Running in Parallel on the Server and Communicating Back to the Browser</h4>
  <div class="col-md-7">
    <p>
      In the next example we will emulate long running server process composed of a number of Tasks, which can be run asynchronously. We want to run it in parallel, change their status when they finish the job and - when all of them are finished - change the status of the whole process.
    </p>
    <p>
      HTML side contains button with <code>drab-click</code> attribute and few DIVs which displays the status of the process and tasks:
<pre><code class="html"><%=~s(Async task status: 
<span id="async_task_status" class="label label-primary">
  ready
</span>
<span class="task label label-danger" data-task_id="1">Task 1</span>
  ...
<span class="task label label-danger" data-task_id="54">Task 54</span>
<button drab-click="run_async_tasks">Start async task</button>)%></code></pre>
    </p>
    <p>
      The whole processing is on the server side. Clicking the button runs <code>run_async_tasks/2</code> function on the server side:
<pre><code class="elixir"><%=~s/def run_async_tasks(socket, dom_sender) do
  socket 
    |> update(".task", :class, "label-success", "label-danger")
    |> update("#async_task_status", :text, "running")
  tasks = Enum.map(1..54, fn(i) -> Task.async(fn -> 
    :timer.sleep(:rand.uniform(4000)) # simulate real task
    update(socket, ".task[data-task_id=#\{i\}]", :class, "label-danger", "label-success")
    end)
  end)
  Enum.each(tasks, fn(task) -> Task.await(task) end)
  update(socket, "#async_task_status", :html, 
    "finished")
  {socket, dom_sender}
end/%></code></pre>
    The code above runs asynchronously 54 Tasks, which just waits some time (up to 4 seconds) and then communicates to the user by changing the boostrap class from <code>label-danger</code> to <code>label-success</code>. After launching he background tasks, it waits (<code>Task.await/1</code>) for all of the tasks to finish and then informs the user by changing the Task status to "finished".
    </p>
    <p>
      You may think: <b>what is the difference between this approach and running 54 AJAX requests which launches action on the controller side?</b> Except of <code>Drab</code> natural beauty, you can't do it with AJAX. You browser <a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">limits the number of simultaneus connections</a>.
    </p>
  </div>
  <div class="col-md-5">
    <p>
      Click the button below to simulate server-side long running process contains asynchronous tasks.
      <h4>Async task status: <span id="async_task_status" class="label label-primary">ready</span></h4>
      <div class="row">
        <%= for i <- 1..54 do %>
          <div class="col-md-2 col-xs-4 centered">
            <span class="task label label-danger" data-task_id="<%= i %>">Task #<%= i |> Integer.to_string |> String.rjust(2, ?0) %></span>
          </div>
        <% end %>
      </div>
      <br>
      <button class="btn btn-primary" drab-click="run_async_tasks">Start async task</button>
    </p>
  </div>
</div>
<hr>
<div class="row">
  <h4>Access to the Sender DOM Object Properties and Async Explained</h4>
  <div class="col-md-7">
    <p>
      The next example shows how we can retrieve the information from <code>data</code> attribute. We've simple set up few buttons, each with the same event function <code>clicked_sleep_button</code>:
      <pre><code class="html"><%=~s(<button drab-click="clicked_sleep_button" data-sleep="1">Sleep 1 second</button>
<button drab-click="clicked_sleep_button" data-sleep="2">Sleep 2 seconds</button>
<button drab-click="clicked_sleep_button" data-sleep="3">Sleep 3 seconds</button>)%></code></pre>
    </p>
    <p>
      On the server side code is not very sophisticated as well. The whole functionality is to sleep for a few seconds. But the number of seconds is given with <code>data</code> property in <code>dom_sender</code> variable. Please notice that this variable contains more interesting values to be used, like <code>val</code>, <code>html</code> or <code>text</code>. All this will be in the documentation, some day.
      <pre><code class="elixir"><%=~s/def clicked_sleep_button(socket, dom_sender) do
  update(socket, this(dom_sender), :prop, "disabled", true)
  :timer.sleep(dom_sender["data"]["sleep"] * 1000)
  update(socket, this(dom_sender), :prop, "disabled", false)
end/%></code></pre>
      With this example we introduce <code>this/1</code> function, which allows you to operate on the DOM object in similar way as with <code>$(this)</code>. That's how we can disable the right button only!
    </p>
    <p>
      Observe that when one button is "processing", you can click another one. This is because <strong>Drab requests are asynchronous on the server side</strong>. This is why it is good to disable button while processing on the server side.
  </div>
  <div class="col-md-5">
    <p>
      Click on the button to sleep<br>
      <button drab-click="clicked_sleep_button" class="btn btn-primary" data-sleep="1">Sleep 1 second</button>
      <button drab-click="clicked_sleep_button" class="btn btn-primary" data-sleep="2">Sleep 2 seconds</button>
      <button drab-click="clicked_sleep_button" class="btn btn-primary" data-sleep="3">Sleep 3 seconds</button>
    </p>
  </div>
</div>
<hr>
<div class="row">
  <h4>Page Load and Some More Events</h4>
  <div class="col-md-7">
    <p>
      Analogically to <code>page load</code> Javascript event, it is possible to run a callback after the client page is loaded (<em>so far it is running every time the websockets connect, so it should be called "onconnect"</em>). Do do it, we need to declare and write a function:
<pre><code class="elixir"><%=~s/defmodule DrabPoc.PageCommander do
  use Drab.Commander, onload: :page_loaded
  def page_loaded(socket) do
    update(socket, "#display_placeholder", :html, "Value set on the server side")
    socket
  end
end/%></code></pre>
    </p>
    <p>
      And this is to show you that not only <code>change</code> event is already supported by Drab :) Remember, this is just a proof of concept.
      <pre><code class="html"><%=~s(<input drab-keyup="changed_input">
<div id="display_placeholder">Some text here</div>)%></code></pre>
      <pre><code class="elixir"><%=~s/def changed_input(socket, dom_sender) do
  update(socket, "#display_placeholder", :text, String.upcase(dom_sender["val"]))
end/%></code></pre>
    </p>
  </div>
  <div class="col-md-5">
    <p>
      Start typing down there:
      <input drab-keyup="changed_input" class="form-control">
      <div id="display_placeholder">Some text here</div>
    </p>
  </div>
</div>
<hr>
<p>
  <h4>
  &copy;2016 Tomek "Grych" Gryszkiewicz, <a href="mailto:grych@tg.pl">grych@tg.pl</a>
  </h4>
</p>

